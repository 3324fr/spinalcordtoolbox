#!/usr/bin/env python

__author__ = 'Simon_2'

# ======================================================================================================================

# Extract results from .txt files generated by " " and draw plots to validate metric extraction.

# ======================================================================================================================
import os
import glob
import getopt
import commands
import sys
import numpy
import re
import matplotlib.pyplot as plt
from matplotlib.legend_handler import *
# import subprocess
# path_sct = subprocess.check_output("echo %SCT_DIR%", shell=True)

class Param:
    def __init__(self):
        self.debug = 0

#=======================================================================================================================
# main
#=======================================================================================================================
def main():

    results_folder = ''

    # Parameters for debug mode
    if param.debug:
        print '\n*** WARNING: DEBUG MODE ON ***\n'
        results_folder = "C:\cygwin64\home\Simon_2\data_simon"
        path_sct = 'C:/cygwin64/home/Simon_2/spinalcordtoolbox'
    else:
        status, path_sct = commands.getstatusoutput('echo $SCT_DIR')

        # Check input parameters
        try:
            opts, args = getopt.getopt(sys.argv[1:], 'i:')  # define flags
        except getopt.GetoptError as err:  # check if the arguments are defined
            print str(err)  # error
            # usage() # display usage
        if not opts:
            sct.printv('Please enter the path to the result folder.', 'error')
            # usage()
        for opt, arg in opts:  # explore flags
            if opt in '-i':
                results_folder = arg

    # Append path that contains scripts, to be able to load modules
    sys.path.append(path_sct + '/scripts')
    import sct_utils as sct

    sct.printv("Working directory: "+os.getcwd())

    sct.printv('\n\nData will be extracted from folder '+results_folder+' .', 'warning')
    sct.printv('\n\t\tCheck existence...')
    sct.check_folder_exist(results_folder)

    fname_results = glob.glob(results_folder + '/*.txt')

    nb_results_file = len(fname_results)

    # 1st dim: SNR, 2nd dim: tract std, 3rd dim: mean abs error, 4th dim: std abs error
    # result_array = numpy.empty((nb_results_file, nb_results_file, 3), dtype=object)
    # SNR
    snr = numpy.zeros((nb_results_file))
    # Tracts std
    tracts_std = numpy.zeros((nb_results_file))
    # methods' name
    methods_name = [] #numpy.empty((nb_results_file, nb_method), dtype=object)
    # median
    median_results = numpy.zeros((nb_results_file, 6))
    # min
    min_results = numpy.zeros((nb_results_file, 6))
    # max
    max_results = numpy.zeros((nb_results_file, 6))

    #
    for i_file in range(0, nb_results_file):

        # Open file
        f = open(fname_results[i_file])  # open file
        # Extract all lines in .txt file
        lines = [line for line in f.readlines() if line.strip()]

        # extract SNR
        # find all index of lines containing the string "sigma noise"
        ind_line_noise = [lines.index(line_noise) for line_noise in lines if "sigma noise" in line_noise]
        if len(ind_line_noise) != 1:
            sct.printv("ERROR: number of lines including \"sigma noise\" is different from 1. Exit program.", 'error')
            sys.exit(1)
        else:
            # result_array[:, i_file, i_file] = int(''.join(c for c in lines[ind_line_noise[0]] if c.isdigit()))
            snr[i_file] = int(''.join(c for c in lines[ind_line_noise[0]] if c.isdigit()))

        # extract tract std
        ind_line_tract_std = [lines.index(line_tract_std) for line_tract_std in lines if "range tracts" in line_tract_std]
        if len(ind_line_tract_std) != 1:
            sct.printv("ERROR: number of lines including \"range tracts\" is different from 1. Exit program.", 'error')
            sys.exit(1)
        else:
            # result_array[i_file, i_file, :] = int(''.join(c for c in lines[ind_line_tract_std[0]].split(':')[1] if c.isdigit()))
            # regex = re.compile(''('(.*)':)  # re.I permet d'ignorer la case (majuscule/minuscule)
            # match = regex.search(lines[ind_line_tract_std[0]])
            # result_array[:, i_file, :, :] = match.group(1)  # le groupe 1 correspond a '.*'
            tracts_std[i_file] = int(''.join(c for c in lines[ind_line_tract_std[0]].split(':')[1] if c.isdigit()))


        # extract method name
        ind_line_label = [lines.index(line_label) for line_label in lines if "Label" in line_label]
        if len(ind_line_label) != 1:
            sct.printv("ERROR: number of lines including \"Label\" is different from 1. Exit program.", 'error')
            sys.exit(1)
        else:
            # methods_name[i_file, :] = numpy.array(lines[ind_line_label[0]].strip().split(',')[1:])
            methods_name.append(lines[ind_line_label[0]].strip().replace(' ', '').split(',')[1:])

        # extract median
        ind_line_median = [lines.index(line_median) for line_median in lines if "median" in line_median]
        if len(ind_line_median) != 1:
            sct.printv("ERROR: number of lines including \"median\" is different from 1. Exit program.", 'error')
            sys.exit(1)
        else:
            median = lines[ind_line_median[0]].strip().split(',')[1:]
            # result_array[i_file, i_file, 0] = [float(m.split('(')[0]) for m in median]
            median_results[i_file, :] = numpy.array([float(m.split('(')[0]) for m in median])

        # extract min
        ind_line_min = [lines.index(line_min) for line_min in lines if "min," in line_min]
        if len(ind_line_min) != 1:
            sct.printv("ERROR: number of lines including \"min\" is different from 1. Exit program.", 'error')
            sys.exit(1)
        else:
            min = lines[ind_line_min[0]].strip().split(',')[1:]
            # result_array[i_file, i_file, 1] = [float(m.split('(')[0]) for m in min]
            min_results[i_file, :] = numpy.array([float(m.split('(')[0]) for m in min])

        # extract max
        ind_line_max = [lines.index(line_max) for line_max in lines if "max" in line_max]
        if len(ind_line_max) != 1:
            sct.printv("ERROR: number of lines including \"max\" is different from 1. Exit program.", 'error')
            sys.exit(1)
        else:
            max = lines[ind_line_max[0]].strip().split(',')[1:]
            # result_array[i_file, i_file, 1] = [float(m.split('(')[0]) for m in max]
            max_results[i_file, :] = numpy.array([float(m.split('(')[0]) for m in max])

        # close file
        f.close()

    # check if all the files in the result folder were generated with the same number of methods
    if not all(x == methods_name[0] for x in methods_name):
        sct.printv('ERROR: All the generated files in folder '+results_folder+' have not been generated with the same number of methods. Exit program.', 'error')
        sys.exit(1)

    # ** TEMPORARY UPDATE NOT TO PLOT METHOD "mlwa" (will be useless when data will be generated without method "mlwa")*
    ind_mlwa = methods_name[0].index('mlwa')
    methods_name[0].remove('mlwa')
    median_results = numpy.delete(median_results, ind_mlwa, 1)
    min_results = numpy.delete(min_results, ind_mlwa, 1)
    max_results = numpy.delete(max_results, ind_mlwa, 1)
    # ******************************************************************************************************************


    nb_method = len(methods_name[0])

    sct.printv('Noise std of the '+str(nb_results_file)+' generated files:')
    print snr
    print '----------------------------------------------------------------------------------------------------------------'
    sct.printv('Tracts std of the '+str(nb_results_file)+' generated files:')
    print tracts_std
    print '----------------------------------------------------------------------------------------------------------------'
    sct.printv('Methods used to generate results for the '+str(nb_results_file)+' generated files:')
    print methods_name
    print '----------------------------------------------------------------------------------------------------------------'
    sct.printv('Median obtained with each method (in colons) for the '+str(nb_results_file)+' generated files (in lines):')
    print median_results
    print '----------------------------------------------------------------------------------------------------------------'
    sct.printv('Minimum obtained with each method (in colons) for the '+str(nb_results_file)+' generated files (in lines):')
    print min_results
    print '----------------------------------------------------------------------------------------------------------------'
    sct.printv('Maximum obtained with each method (in colons) for the '+str(nb_results_file)+' generated files (in lines):')
    print max_results

    # # plot A
    # fig0 = plt.figure(0)
    # fig0.suptitle('Absolute error within all tracts as a function of noise std')
    #
    # fig0_ax = fig0.add_subplot(111)
    # fig0_ax.grid(True)
    # fig0_ax.set_xlabel('Noise std')
    # fig0_ax.set_ylabel('Absolute error')
    # colors = plt.get_cmap('jet')(np.linspace(0, 1.0, nb_method))
    #
    # for meth, color in zip(methods_name[0], colors):
    #     if meth != 'mlwa':
    #         i_meth = methods_name[0].index(meth)
    #
    #         # median
    #         plt.plot(snr[ind_tracts_std_10], median_results[ind_tracts_std_10, i_meth][0], label='median '+meth, color=color, marker='o', linestyle='None', markersize=5.0, linewidth=2.0)
    #         # min
    #         plt.plot(snr[ind_tracts_std_10], min_results[ind_tracts_std_10, i_meth][0], label='min '+meth, color=color, marker='_', linestyle='None', markersize=10.0, linewidth=20.0)
    #         # max
    #         plt.plot(snr[ind_tracts_std_10], max_results[ind_tracts_std_10, i_meth][0], label='max '+meth, color=color, marker='+', linestyle='None', markersize=10.0, linewidth=20.0)
    #
    # handles, labels = fig0_ax.get_legend_handles_labels()
    # fig0_ax.legend(handles, labels, loc='best', handler_map={Line2D: HandlerLine2D(numpoints=1)}, fontsize=16)
    #
    #
    # # plot B
    # fig1 = plt.figure(1)
    # fig1.suptitle('Absolute error within all tracts as a function of tract std')
    #
    # fig1_ax = fig1.add_subplot(111)
    # fig1_ax.grid(True)
    # fig1_ax.set_xlabel('Tract std (percentage of the true value in tract)')
    # fig1_ax.set_ylabel('Absolute error')
    # colors = plt.get_cmap('jet')(np.linspace(0, 1.0, nb_method))
    #
    # for meth, color in zip(methods_name[0], colors):
    #     if meth != 'mlwa':
    #         i_meth = methods_name[0].index(meth)
    #
    #         # median
    #         plt.plot(tracts_std[ind_snr_10], median_results[ind_snr_10, i_meth][0], label='median '+meth, color=color, marker='o', linestyle='None', markersize=5.0, linewidth=2.0)
    #         # min
    #         plt.plot(tracts_std[ind_snr_10], min_results[ind_snr_10, i_meth][0], label='min '+meth, color=color, marker='_', linestyle='None', markersize=10.0, linewidth=20.0)
    #         # max
    #         plt.plot(tracts_std[ind_snr_10], max_results[ind_snr_10, i_meth][0], label='max '+meth, color=color, marker='+', linestyle='None', markersize=10.0, linewidth=20.0)
    #
    # handles, labels = fig1_ax.get_legend_handles_labels()
    # fig1_ax.legend(handles, labels, loc='best', handler_map={Line2D: HandlerLine2D(numpoints=1)}, fontsize=16)

    # Plot A
    ind_tracts_std_10 = numpy.where(tracts_std == 10)  # indexes where TRACTS STD=10
    ind_ind_snr_sort_tracts_std_10 = numpy.argsort(snr[ind_tracts_std_10])  # indexes of indexes where TRACTS STD=10 sorted according to SNR values (in ascending order)
    ind_snr_sort_tracts_std_10 = ind_tracts_std_10[0][ind_ind_snr_sort_tracts_std_10]  # indexes where TRACTS STD=10 sorted according to SNR values (in ascending order)

    fig2 = plt.figure(2)
    ind_fig2 = numpy.arange(len(snr[ind_snr_sort_tracts_std_10]))*1.2
    width = 1.0/(nb_method+1)
    plt.ylabel('Absolute error (%)')
    plt.xlabel('Noise std')
    plt.title('Absolute error within all tracts as a function of noise std')
    plt.xticks(ind_fig2+0.5, snr[ind_snr_sort_tracts_std_10])
    plt.gca().set_xlim([-width/(nb_method+1), numpy.max(ind_fig2)+1])
    plt.gca().yaxis.grid(True)

    colors = plt.get_cmap('jet')(np.linspace(0, 1.0, nb_method))
    bar_plots = []
    for meth, color in zip(methods_name[0], colors):
        i_meth = methods_name[0].index(meth)

        plot_i = plt.bar(ind_fig2+i_meth*width+(float(i_meth)*width)/(nb_method+1), max_results[ind_snr_sort_tracts_std_10, i_meth]-min_results[ind_snr_sort_tracts_std_10, i_meth], width, min_results[ind_snr_sort_tracts_std_10, i_meth], edgecolor=color, color='white', linewidth=3)
        plt.plot(ind_fig2+i_meth*width+width/2+(float(i_meth)*width)/(nb_method+1), median_results[ind_snr_sort_tracts_std_10, i_meth], color=color, marker='_', linestyle='None', markersize=200*width, markeredgewidth=3)
        bar_plots.append(plot_i[0])

    plt.legend(bar_plots, methods_name[0], bbox_to_anchor=(1.01, 1), loc=2, borderaxespad=0.)

    # Plot B
    ind_snr_10 = numpy.where(snr == 10)  # indexes where SNR=10
    ind_ind_tracts_std_sort_snr_10 = numpy.argsort(tracts_std[ind_snr_10])  # indexes of indexes where SNR=10 sorted according to tracts_std values (in ascending order)
    ind_tracts_std_sort_snr_10 = ind_snr_10[0][ind_ind_tracts_std_sort_snr_10]  # indexes where SNR=10 sorted according to tracts_std values (in ascending order)

    fig3 = plt.figure(3)
    ind_fig3 = numpy.arange(len(tracts_std[ind_tracts_std_sort_snr_10]))*1.2
    width = 1.0/(nb_method+1)
    plt.ylabel('Absolute error (%)')
    plt.xlabel('Tracts std (in percentage of the mean value of the tracts)')
    plt.title('Absolute error within all tracts as a function of tracts std')
    plt.xticks(ind_fig3+0.5, tracts_std[ind_tracts_std_sort_snr_10])
    plt.gca().set_xlim([-width/(nb_method+1), numpy.max(ind_fig2)+1])
    plt.gca().yaxis.grid(True)

    colors = plt.get_cmap('jet')(np.linspace(0, 1.0, nb_method))
    bar_plots = []
    for meth, color in zip(methods_name[0], colors):
        i_meth = methods_name[0].index(meth)

        plot_i = plt.bar(ind_fig3+i_meth*width+(float(i_meth)*width)/(nb_method+1), max_results[ind_tracts_std_sort_snr_10, i_meth]-min_results[ind_tracts_std_sort_snr_10, i_meth], width, min_results[ind_tracts_std_sort_snr_10, i_meth], edgecolor=color, color='white', linewidth=3)
        plt.plot(ind_fig2+i_meth*width+width/2+(float(i_meth)*width)/(nb_method+1), median_results[ind_tracts_std_sort_snr_10, i_meth], color=color, marker='_', linestyle='None', markersize=200*width, markeredgewidth=3)
        bar_plots.append(plot_i[0])

    plt.legend(bar_plots, methods_name[0], bbox_to_anchor=(1.01, 1), loc=2, borderaxespad=0.)


    plt.show()

#=======================================================================================================================
# Start program
#=======================================================================================================================
if __name__ == "__main__":
    param_default = Param()
    param = Param()
    # call main function
    main()