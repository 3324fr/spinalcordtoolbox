#!/usr/bin/env python

__author__ = 'Simon_2'

# ======================================================================================================================

# Extract results from .txt files generated by " " and draw plots to validate metric extraction.

# ======================================================================================================================

# ******************************TO BE UPDATED ACCORDING TO THE USER*****************************************************
results_folder = "C:\cygwin64\home\Simon_2\data_simon"
# **********************************************************************************************************************

import os
import glob
import commands
import sys
import numpy
import re
import pylab as plt
from matplotlib.legend_handler import *
import matplotlib.cm as cm
# import subprocess
# path_sct = subprocess.check_output("echo %SCT_DIR%", shell=True)
status, path_sct = commands.getstatusoutput('echo $SCT_DIR')
# path_sct = 'C:/cygwin64/home/Simon_2/spinalcordtoolbox'
# Append path that contains scripts, to be able to load modules
sys.path.append(path_sct + '/scripts')
import sct_utils as sct
from msct_parser import *

sct.printv("Working directory: "+os.getcwd())

fname_results = glob.glob(results_folder + '/*.txt')

nb_results_file = len(fname_results)
nb_method = 6

# 1st dim: SNR, 2nd dim: tract std, 3rd dim: mean abs error, 4th dim: std abs error
# result_array = numpy.empty((nb_results_file, nb_results_file, 3), dtype=object)
# SNR
snr = numpy.zeros((nb_results_file))
# Tracts std
tracts_std = numpy.zeros((nb_results_file))
# methods' name
methods_name = [] #numpy.empty((nb_results_file, nb_method), dtype=object)
# median
median_results = numpy.zeros((nb_results_file, 6))
# min
min_results = numpy.zeros((nb_results_file, 6))
# max
max_results = numpy.zeros((nb_results_file, 6))

#
for i_file in range(0, nb_results_file):

    # Open file
    f = open(fname_results[i_file])  # open file
    # Extract all lines in .txt file
    lines = [line for line in f.readlines() if line.strip()]

    # extract SNR
    # find all index of lines containing the string "sigma noise"
    ind_line_noise = [lines.index(line_noise) for line_noise in lines if "sigma noise" in line_noise]
    if len(ind_line_noise) != 1:
        sct.printv("ERROR: number of lines including \"sigma noise\" is different from 1", 'error')
    else:
        # result_array[:, i_file, i_file] = int(''.join(c for c in lines[ind_line_noise[0]] if c.isdigit()))
        snr[i_file] = int(''.join(c for c in lines[ind_line_noise[0]] if c.isdigit()))

    # extract tract std
    ind_line_tract_std = [lines.index(line_tract_std) for line_tract_std in lines if "range tracts" in line_tract_std]
    if len(ind_line_tract_std) != 1:
        sct.printv("ERROR: number of lines including \"range tracts\" is different from 1", 'error')
    else:
        # result_array[i_file, i_file, :] = int(''.join(c for c in lines[ind_line_tract_std[0]].split(':')[1] if c.isdigit()))
        # regex = re.compile(''('(.*)':)  # re.I permet d'ignorer la case (majuscule/minuscule)
        # match = regex.search(lines[ind_line_tract_std[0]])
        # result_array[:, i_file, :, :] = match.group(1)  # le groupe 1 correspond a '.*'
        tracts_std[i_file] = int(''.join(c for c in lines[ind_line_tract_std[0]].split(':')[1] if c.isdigit()))


    # extract method name
    ind_line_label = [lines.index(line_label) for line_label in lines if "Label" in line_label]
    if len(ind_line_label) != 1:
        sct.printv("ERROR: number of lines including \"Label\" is different from 1", 'error')
    else:
        # methods_name[i_file, :] = numpy.array(lines[ind_line_label[0]].strip().split(',')[1:])
        methods_name.append(lines[ind_line_label[0]].strip().split(',')[1:])

    # extract median
    ind_line_median = [lines.index(line_median) for line_median in lines if "median" in line_median]
    if len(ind_line_median) != 1:
        sct.printv("ERROR: number of lines including \"median\" is different from 1", 'error')
    else:
        median = lines[ind_line_median[0]].strip().split(',')[1:]
        # result_array[i_file, i_file, 0] = [float(m.split('(')[0]) for m in median]
        median_results[i_file, :] = numpy.array([float(m.split('(')[0]) for m in median])

    # extract min
    ind_line_min = [lines.index(line_min) for line_min in lines if "min," in line_min]
    if len(ind_line_min) != 1:
        sct.printv("ERROR: number of lines including \"min\" is different from 1", 'error')
    else:
        min = lines[ind_line_min[0]].strip().split(',')[1:]
        # result_array[i_file, i_file, 1] = [float(m.split('(')[0]) for m in min]
        min_results[i_file, :] = numpy.array([float(m.split('(')[0]) for m in min])

    # extract max
    ind_line_max = [lines.index(line_max) for line_max in lines if "max" in line_max]
    if len(ind_line_max) != 1:
        sct.printv("ERROR: number of lines including \"max\" is different from 1", 'error')
    else:
        max = lines[ind_line_max[0]].strip().split(',')[1:]
        # result_array[i_file, i_file, 1] = [float(m.split('(')[0]) for m in max]
        max_results[i_file, :] = numpy.array([float(m.split('(')[0]) for m in max])

    # close file
    f.close()

print snr
print '----------------------------------------------'
print tracts_std
print '----------------------------------------------'
print methods_name
print '----------------------------------------------'
print median_results
print '----------------------------------------------'
print min_results
print '----------------------------------------------'
print max_results

# plot A
ind_snr_10 = numpy.where(snr == 10)
ind_tracts_std_10 = numpy.where(tracts_std == 10)

fig0 = plt.figure(0)
fig0.suptitle('Absolute error within all tracts as a function of noise std')

fig0_ax = fig0.add_subplot(111)
fig0_ax.grid(True)
fig0_ax.set_xlabel('Noise std')
fig0_ax.set_ylabel('Absolute error')
colors = plt.get_cmap('jet')(np.linspace(0, 1.0, nb_method))

for meth, color in zip(methods_name[0], colors):
    i_meth = methods_name[0].index(meth)

    # median
    plt.plot(snr[ind_tracts_std_10], median_results[ind_tracts_std_10, i_meth][0], label='median '+meth, color=color, marker='o', linestyle='None', markersize=5.0, linewidth=2.0)
    # min
    plt.plot(snr[ind_tracts_std_10], min_results[ind_tracts_std_10, i_meth][0], label='min '+meth, color=color, marker='_', linestyle='None', markersize=10.0, linewidth=20.0)
    # max
    plt.plot(snr[ind_tracts_std_10], max_results[ind_tracts_std_10, i_meth][0], label='max '+meth, color=color, marker='+', linestyle='None', markersize=10.0, linewidth=20.0)

handles, labels = fig0_ax.get_legend_handles_labels()
fig0_ax.legend(handles, labels, loc='best', handler_map={Line2D: HandlerLine2D(numpoints=1)}, fontsize=16)


# plot B
fig1 = plt.figure(1)
fig1.suptitle('Absolute error within all tracts as a function of tract std')

fig1_ax = fig1.add_subplot(111)
fig1_ax.grid(True)
fig1_ax.set_xlabel('Tract std (percentage of the true value in tract)')
fig1_ax.set_ylabel('Absolute error')
colors = plt.get_cmap('jet')(np.linspace(0, 1.0, nb_method))

for meth, color in zip(methods_name[0], colors):
    i_meth = methods_name[0].index(meth)

    # median
    plt.plot(tracts_std[ind_snr_10], median_results[ind_snr_10, i_meth][0], label='median '+meth, color=color, marker='o', linestyle='None', markersize=5.0, linewidth=2.0)
    # min
    plt.plot(tracts_std[ind_snr_10], min_results[ind_snr_10, i_meth][0], label='min '+meth, color=color, marker='_', linestyle='None', markersize=10.0, linewidth=20.0)
    # max
    plt.plot(tracts_std[ind_snr_10], max_results[ind_snr_10, i_meth][0], label='max '+meth, color=color, marker='+', linestyle='None', markersize=10.0, linewidth=20.0)

handles, labels = fig1_ax.get_legend_handles_labels()
fig1_ax.legend(handles, labels, loc='best', handler_map={Line2D: HandlerLine2D(numpoints=1)}, fontsize=16)

plt.show()